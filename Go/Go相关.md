# Go原理相关

## Goroutine调度模型

 https://www.cnblogs.com/linguanh/p/9510746.html 

G：一个Goroutine模型，相当于PCB

M：一个线程模型，有线程栈，用于执行G

P：一个处理器模型，当P有任务时需要绑定一个M来执行G

### 过程

##### 正常情况

创建一个G，保存到本地P队列或者全局队列，然后P去唤醒一个M，P继续执行当前队列，M找有无空闲P，有则把G移动到队列中，循环调用G对象，执行，清理线程，继续找G

M执行中，可能会发生G的切换，这时候需要保存现场，由于M的栈保存在G对象上，M把寄存器SP，PC保存到G上即可，G保存好现场后，重新丢到P的任务队列，等待下一次被调度执行

##### 阻塞情况

创建一个新的M，把G绑定当前M，然后把P和剩余队列绑定新的M

##### 队列完成情况

当一个G队列执行完成，先从全局队列取，没有则会从另一个G队列获取一半

### 高并发原因

能合理利用所有CPU，CPU数量等于P数量，一个线程等于一个M，每个P都能执行G队列，充分利用多核。实现原生并发。

### 面试问题

##### Goroutine过多了怎么办

当goroutine过多了，例如10E，P队列积压，Go调度器就会阻塞goroutine，，可以考虑实现一个协程池

 https://studygolang.com/articles/13344 

##### goroutine协程被称为轻量化线程的原因

同线程被称为轻量进程的原因，首先是因为协程创建代价比线程少，因为线程有独立的栈，而协程为了避免资源浪费，是动态扩展收缩的（初始为2k，最大为1G），而且协程的调度开销比线程小，线程涉及用户态到内核态的模式切换，寄存器的刷新等，而协程在用户态由调度器完成切换，只修改PC+SP+DX

## Go的GC原理

三色标记法+写屏障

触发时机：2分钟or内存到达一个阈值（默认扩大一倍）or手动runtime.gc()

（GC的扫描和go代码可以同时运行，所以需要写屏障）

### 原理

##### 标记阶段

stw（砸瓦鲁多，1.8后取消），写屏障，然后把全部G标白色

##### 扫描阶段

从root遍历全局指针和goroutine栈上指针，标灰色加入队列，遍历灰色队列，遍历完都为黑色则灰色变黑色

如果中途有新引入对象或者修改了对象到黑色负责引用，通过写屏障标记为灰色，同时把当前黑色对象置为灰色

##### 重新标记阶段

stw，重新扫描在灰色队列中的根对象，

##### 清除阶段

当灰色队列为空，关闭写屏障，最终黑色对象保留，白色对象回收

## make和new区别

都在堆上分配内存

new是分配内存后初始化为0并返回一个**T指针**

make是在分配内存后返回一个有初始值的**类型T**（只适用于slice,map,channel）



