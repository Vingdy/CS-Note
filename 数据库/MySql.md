# MySql 

存储引擎：Innodb和myisam（都是B+树）

| Innodb                       | myisam                           |
| ---------------------------- | -------------------------------- |
| 聚簇索引（叶子结点就是数据） | 非聚簇索引（叶子结点是数据地址） |
| 支持事务                     | 不支持事务                       |
| 支持外键                     | 不支持外键                       |
| 支持行级锁                   | 支持表级锁                       |
| 支持MVCC                     | 不支持MVCC                       |

事务：一条SQL语句，一组SQL语句或整个程序。是恢复和[并发控制](https://baike.baidu.com/item/并发控制)的基本单位。

事务的ACID属性：原子性，一致性，隔离性，持续性

原子：每个事务不可分割，要么做，要么不做

一致性：事务是使数据库从一个一致性状态变到另一个一致性

持续性：事务一旦提交，对数据库修改是永久性的

隔离性：事务之间不能互相干扰 

## 四个隔离级别

未提交读：RU（脏读+不可重复读+幻读），数据有写锁，无读锁

已提交读：RC（不可重复读+幻读），每个数据加入排他锁和共享锁，不能共存，但可有多个共享锁，并读完就释放

可重复读：RR，MySql默认级别（幻读，MVCC可以解决），共享锁修改，事务准备提交才释放

可串行化：S（无），事务只能一件件完成

附：

脏读：A事务运行一个查询，B事务在查询前修改，查询后回滚，B事务完成，此时数据错误

不可重复读：A事务运行两次查询，B事务在查询中修改，A第一次查询错误

幻读：A事务修改某行后查询，B事务中途插入同一数据，A事务看起来像没有修改

## explain优化

信息很多，主要看type

system(一行)>const(一次索引)>eq_ref(唯一索引扫描)>ref(非唯一索引扫描)>range(特定行)>index(索引树)>all(全表)

执行顺序：
from->on->join->where->group by->having->select->distinct->order by->limit
简记：先构造虚拟表，然后select，再对表处理

## B+树性质与使用原因

 http://www.sohu.com/a/280609547_818692 

#### B+树性质

m阶B+树

①每个节点最多包含m个子节点

②如果根节点包含子节点，则至少包含 2 个子节点；除根节点外，每个非叶节点至少包含 m/2 个子节点

③拥有 k 个子节点的非叶节点将包含 k - 1 条记录

④所有叶节点都在同一层中

**⑤只有叶子节点存储真实的数据，非叶节点只存储键**

**⑥叶节点之间通过双向链表链接 **

#### 为什么B+树不是B树或者红黑树或者哈希

红黑树：一种平衡二叉树，但是一个节点数据只存储一个值，相对树高比较高，搜索速度比B+树差

B树：多路平衡查找树，跟B+树相比没有⑤⑥点，但是在多条数据选择上需要中序遍历返回，没有B+树高效

哈希：速度为O(1)，比B+树的O(logn)快，只选一个数据哈希快，但是在多个数据情况下，B+树索引有序且叶子节点有链表相连，查询效率比哈希高

B+树：索引保存在磁盘上，数据量大可能一次无法装入内存，B+树设计可以分批加载，同时树高比较低，多数据查询时叶子节点有双向链表，不用返回遍历，查找效率高。

## MySql锁

 https://www.nowcoder.com/discuss/151430 

大类型：行锁、表锁、行锁

行锁：共享锁S、排他锁X

表锁：意向共享锁IS、意向排他锁IX

#### 兼容情况

如果一个事务请求的锁模式与当前锁兼容，InnoDB就请求的锁授予该事务;
反之，如果两者两者不兼容，该事务就要等待锁释放

| 当前锁/是否兼容/请求锁 | X    | IX   | S    | IS   |
| ---------------------- | ---- | ---- | ---- | ---- |
| X                      | 冲突 | 冲突 | 冲突 | 冲突 |
| IX                     | 冲突 | 兼容 | 冲突 | 兼容 |
| S                      | 冲突 | 冲突 | 兼容 | 兼容 |
| IS                     | 冲突 | 兼容 | 兼容 | 兼容 |

简单理解记录：

共享锁一般用于事务读加锁，其他事务可以再加S锁，但是不能再加X锁，保证可以读，但不能修改

排他锁一般用于事务写加锁，其他事务不能再加锁，保证修改时候没有其他事务读或改

意向锁都是表锁，通常用于在加表行对应锁之前获取表的意向锁，避免全表扫描锁而是只用获取对应的意向锁即可，意向锁之间互相兼容，意向共享锁对共享锁兼容。

意向锁是InnoDB自动加的，不需用户干预
对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及及数据集加排他锁（Ｘ）
对于普通SELECT语句，InnoDB不会加任何锁

共享锁语句主要用在需要数据依存关系时确认某行记录是否存在
并确保没有人对这个记录UPDATE或DELETE
但如果当前事务也需要对该记录进行更新，则很有可能造成死锁
对于锁定行记录后需要进行更新操作的应用，应该使用排他锁语句

#### 行锁

通过给索引上的索引项加锁来实现

行锁基于索引实现，如果不通过索引访问数据，InnoDB会使用表锁

##### 间隙锁（Next-Key锁）

 当我们用范围条件而不是相等条件检索数据,并请求共享或排他锁时,InnoDB会给符合条件的已有数据的索引项加锁；此时对于键值在条件范围内但并不存在的记录，叫做“间隙(GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）

##### 目的

①防止幻读，以满足相关隔离级别的要求

对于上例，若不使用间隙锁,如果其他事务插入 empid 大于 100 的任何记录
那么本事务如果再次执行上述语句，就会发生幻读

②满足其恢复和复制的需要

在使用范围条件检索并锁定记录时；
InnoDB 这种加锁机制会阻塞符合条件范围内键值的并发插入，这往往会造成严重的锁等待；
因此,在实际开发中，尤其是并发插入较多的应用；
我们要尽量优化业务逻辑，尽量使用**相等条件来访问更新数据**,避免使用范围条件

①普通索引

②唯一索引

③主键索引

④联合索引

⑤单列索引

